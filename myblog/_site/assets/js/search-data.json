{"0": {
    "doc": "C#",
    "title": " C#",
    "content": " ",
    "url": "/2025-03-03-C%23.html#-c",
    
    "relUrl": "/2025-03-03-C%23.html#-c"
  },"1": {
    "doc": "C#",
    "title": "Official website",
    "content": "The official website for C# is maintained by Microsoft. For comprehensive documentation, tutorials, and resources, you can visit: . https://learn.microsoft.com/en-us/dotnet/csharp/ . This site provides everything you need to get started with C#, including guides, reference documentation, and community resources. ",
    "url": "/2025-03-03-C%23.html#official-website",
    
    "relUrl": "/2025-03-03-C%23.html#official-website"
  },"2": {
    "doc": "C#",
    "title": "Static typing",
    "content": "Yes, C# is a statically typed language. This means that the type of every variable is known at compile time, and type checking is performed during compilation. Errors related to types (like assigning a value of the wrong type) are caught early, which can help reduce runtime errors. For example, when declaring a variable: . int number = 42; . Here, the variable number is explicitly declared as an int. The compiler will enforce that only integer values can be assigned to number. If you try to assign a string to number, like below: . number = \"forty-two\"; // This will cause a compile-time error. The compiler will generate an error because a string cannot be implicitly converted to an integer. Such behavior is a hallmark of statically typed languages. ",
    "url": "/2025-03-03-C%23.html#static-typing",
    
    "relUrl": "/2025-03-03-C%23.html#static-typing"
  },"3": {
    "doc": "C#",
    "title": "Example code",
    "content": "Below is an example C# implementation of a binary search tree (BST) along with a method to find a value in the tree. This example includes a simple Node class, a BinarySearchTree class containing an iterative search method, as well as a short Main method to demonstrate usage. using System; namespace BSTSearchExample { // Definition for a tree node. public class TreeNode { public int Value; public TreeNode Left; public TreeNode Right; public TreeNode(int value) { Value = value; Left = null; Right = null; } } // Binary search tree implementation. public class BinarySearchTree { public TreeNode Root; public BinarySearchTree() { Root = null; } // Insert a value into the BST. public void Insert(int value) { if (Root == null) { Root = new TreeNode(value); } else { InsertHelper(Root, value); } } private void InsertHelper(TreeNode node, int value) { if (value &lt; node.Value) { if (node.Left == null) { node.Left = new TreeNode(value); } else { InsertHelper(node.Left, value); } } else // assuming duplicate values go to the right subtree { if (node.Right == null) { node.Right = new TreeNode(value); } else { InsertHelper(node.Right, value); } } } // Iterative search method to find a value in the BST. public TreeNode Find(int value) { TreeNode current = Root; while (current != null) { if (value == current.Value) { return current; } else if (value &lt; current.Value) { current = current.Left; } else { current = current.Right; } } return null; // Value not found } // Alternatively, a recursive search method. public TreeNode FindRecursive(int value) { return FindRecursiveHelper(Root, value); } private TreeNode FindRecursiveHelper(TreeNode node, int value) { if (node == null) return null; if (node.Value == value) return node; else if (value &lt; node.Value) return FindRecursiveHelper(node.Left, value); else return FindRecursiveHelper(node.Right, value); } } class Program { static void Main(string[] args) { // Build the BST BinarySearchTree bst = new BinarySearchTree(); int[] values = { 50, 30, 20, 40, 70, 60, 80 }; foreach (int value in values) { bst.Insert(value); } // Search for a value using iterative method. int searchValue = 40; TreeNode foundNode = bst.Find(searchValue); if (foundNode != null) { Console.WriteLine($\"Value {searchValue} found in BST.\"); } else { Console.WriteLine($\"Value {searchValue} not found in BST.\"); } // Search for a value using recursive method. searchValue = 25; TreeNode recursiveFoundNode = bst.FindRecursive(searchValue); if (recursiveFoundNode != null) { Console.WriteLine($\"Value {searchValue} found in BST (recursive search).\"); } else { Console.WriteLine($\"Value {searchValue} not found in BST (recursive search).\"); } } } } . Explanation . | TreeNode Class: . | Each TreeNode stores an integer value and references to its left and right children. | . | BinarySearchTree Class: . | The Insert method adds nodes to the BST following BST properties. | Two methods are provided for searching: . | Find(int value): Uses an iterative approach. | FindRecursive(int value): Uses recursion to search for the value. | . | Both methods return the node if found, or null if not found. | . | Program Class: . | The Main method builds a BST using an array of sample values. | It then demonstrates the search operations with both iterative and recursive methods. | . | . You can compile and run this code using any C# compiler or in an IDE (e.g., Visual Studio). ",
    "url": "/2025-03-03-C%23.html#example-code",
    
    "relUrl": "/2025-03-03-C%23.html#example-code"
  },"4": {
    "doc": "C#",
    "title": "C#",
    "content": " ",
    "url": "/2025-03-03-C%23.html",
    
    "relUrl": "/2025-03-03-C%23.html"
  },"5": {
    "doc": "C++",
    "title": " C++",
    "content": " ",
    "url": "/2025-03-03-C++.html#-c",
    
    "relUrl": "/2025-03-03-C++.html#-c"
  },"6": {
    "doc": "C++",
    "title": "Official website",
    "content": "The C++ programming language doesn’t have an “official” website maintained by a single central authority like some other languages. However, the C++ Standards Committee and the ISO C++ Foundation support a central resource at: . https://isocpp.org . This site provides a wealth of information about the C++ language, its standards, upcoming developments, community resources, and more. It’s widely regarded as the go-to resource for anything related to modern C++. Additionally, while some websites (for example, cplusplus.com) exist and are popular, they are community-run and not officially maintained by the organizations responsible for the C++ standard. ",
    "url": "/2025-03-03-C++.html#official-website",
    
    "relUrl": "/2025-03-03-C++.html#official-website"
  },"7": {
    "doc": "C++",
    "title": "Static typing",
    "content": "Yes, C++ is a statically typed language. In C++, the type of every variable and expression is known at compile time, and the compiler enforces type constraints during compilation. This means that type-related errors, such as trying to assign a value of one type to a variable of another incompatible type, are caught before the program runs. That said, C++ does have some dynamic features: . | Runtime type identification (RTTI): This mechanism allows programs to identify the type of an object at runtime using features like dynamic_cast and typeid. | Polymorphism: Through virtual functions, C++ supports runtime polymorphism, which allows the program to decide at runtime which function to invoke. | Type Casting: C++ provides both compile-time casts (e.g., static_cast) and runtime casts (e.g., dynamic_cast) to allow conversions between different types. | . However, these dynamic features operate within the framework of a predominantly statically typed system, where most type checks happen at compile time. ",
    "url": "/2025-03-03-C++.html#static-typing",
    
    "relUrl": "/2025-03-03-C++.html#static-typing"
  },"8": {
    "doc": "C++",
    "title": "Example code",
    "content": "Below is a complete C++ example that defines a simple binary search tree (BST) and implements a function to search for a value within the tree. In this example, the tree nodes contain integer values, but you can adjust the data type as needed. #include &lt;iostream&gt; // Structure representing a node in the BST struct TreeNode { int value; TreeNode* left; TreeNode* right; TreeNode(int val) : value(val), left(nullptr), right(nullptr) {} }; // Function to insert a new value into the BST TreeNode* insert(TreeNode* root, int val) { if (root == nullptr) { return new TreeNode(val); } if (val &lt; root-&gt;value) { root-&gt;left = insert(root-&gt;left, val); } else if (val &gt; root-&gt;value) { root-&gt;right = insert(root-&gt;right, val); } // If the value is already in the BST, we do not insert duplicates. return root; } // Function to search for a given value in the BST // Returns a pointer to the node containing the value, or nullptr if not found. TreeNode* search(TreeNode* root, int target) { if (root == nullptr) { return nullptr; // Value not found; reached a leaf node's child. } if (target == root-&gt;value) { return root; // Value found. } // Recurse down the tree. If target is less than current node's value, search the left subtree, else the right. if (target &lt; root-&gt;value) { return search(root-&gt;left, target); } else { return search(root-&gt;right, target); } } int main() { // Create a simple BST by inserting values. TreeNode* root = nullptr; int valuesToInsert[] = { 50, 30, 70, 20, 40, 60, 80 }; for (int val : valuesToInsert) { root = insert(root, val); } // The value we want to search for int target = 60; TreeNode* result = search(root, target); if (result != nullptr) std::cout &lt;&lt; \"Value \" &lt;&lt; target &lt;&lt; \" found in the BST.\" &lt;&lt; std::endl; else std::cout &lt;&lt; \"Value \" &lt;&lt; target &lt;&lt; \" not found in the BST.\" &lt;&lt; std::endl; // Cleanup: Ideally, you should free the tree memory here. // For a quick example, we won't implement the deletion logic. return 0; } . Explanation . | Structure Definition (TreeNode): . | Each node holds an integer value and two pointers: left and right. | . | Insert Function: . | The insert function adds a new value to the BST. It recursively finds the correct position based on the BST property (left subtree contains values less than the node, right subtree contains values greater). | . | Search Function: . | The search function recursively traverses the tree. If the node is nullptr, it means the value was not found. If the current node’s value equals the target, the node is returned. Otherwise, the function continues searching in the left or right subtree based on the comparison. | . | Main Function: . | A BST is built by inserting a set of values. The target value is searched in the BST, and the result is printed accordingly. | . | . This code is complete, correct, and runnable. You can compile it with a C++ compiler (such as g++) and run it to see how the BST search works. ",
    "url": "/2025-03-03-C++.html#example-code",
    
    "relUrl": "/2025-03-03-C++.html#example-code"
  },"9": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/2025-03-03-C++.html",
    
    "relUrl": "/2025-03-03-C++.html"
  },"10": {
    "doc": "C",
    "title": " C",
    "content": " ",
    "url": "/2025-03-03-C.html#-c",
    
    "relUrl": "/2025-03-03-C.html#-c"
  },"11": {
    "doc": "C",
    "title": "Official website",
    "content": "The C programming language does not have an official website maintained by any central authority. Instead, its specifications are maintained and published by standards organizations such as ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission). For example: . | The current international standard for the C language is ISO/IEC 9899:2018 (often referred to as C18). You can view information about this standard through the ISO website: ISO/IEC 9899:2018 . | Historically, the ANSI C standard (from the American National Standards Institute) also played a key role in the language’s standardization. | . If you’re looking for resources, tutorials, and community information about C, there are many reputable sites (e.g., https://en.cppreference.com/w/c) and communities, but none of these serve as an “official” website for the language itself. So in summary, while you won’t find a singular “official website of C,” the standards maintained by ISO/IEC can be considered the closest thing to an official reference, and you can find more details by visiting the ISO link provided above. ",
    "url": "/2025-03-03-C.html#official-website",
    
    "relUrl": "/2025-03-03-C.html#official-website"
  },"12": {
    "doc": "C",
    "title": "Static typing",
    "content": "Yes, C is a statically typed language. This means that the type of every variable is known at compile time, and types must be explicitly declared (with some exceptions via type inference in more modern languages, but not in C). The compiler uses the type information to perform type checking and ensure type safety before the program runs. As a result, many type errors are caught during compilation rather than at runtime, reducing a whole class of potential runtime errors. ",
    "url": "/2025-03-03-C.html#static-typing",
    
    "relUrl": "/2025-03-03-C.html#static-typing"
  },"13": {
    "doc": "C",
    "title": "Example code",
    "content": "Below is an example of a C algorithm that searches for a value in a binary search tree (BST). This example defines a basic BST structure, a function to search for a value recursively, and a main function that demonstrates how to use the search function. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // Define the structure for a tree node. typedef struct Node { int data; struct Node* left; struct Node* right; } Node; // Helper function to create a new node. Node* createNode(int data) { Node* newNode = (Node*)malloc(sizeof(Node)); if (newNode == NULL) { fprintf(stderr, \"Memory allocation error!\\n\"); exit(EXIT_FAILURE); } newNode-&gt;data = data; newNode-&gt;left = newNode-&gt;right = NULL; return newNode; } // Function to insert a value into the BST. Node* insert(Node* root, int data) { // If tree is empty, return a new node. if (root == NULL) { return createNode(data); } // Otherwise, recur down the tree. if (data &lt; root-&gt;data) { root-&gt;left = insert(root-&gt;left, data); } else if (data &gt; root-&gt;data) { root-&gt;right = insert(root-&gt;right, data); } // Return the unchanged node pointer. return root; } // Recursive function to find a value in the BST. Node* search(Node* root, int key) { // Base Cases: root is null or key is present at root. if (root == NULL) { return NULL; } if (root-&gt;data == key) { return root; } // Key is greater than root's data. if (key &lt; root-&gt;data) { return search(root-&gt;left, key); } else { return search(root-&gt;right, key); } } // Function to free the BST nodes. void freeTree(Node* root) { if (root != NULL) { freeTree(root-&gt;left); freeTree(root-&gt;right); free(root); } } // Main function to demonstrate usage. int main(void) { Node* root = NULL; int values[] = {50, 30, 20, 40, 70, 60, 80}; int n = sizeof(values) / sizeof(values[0]); // Insert values into the BST. for (int i = 0; i &lt; n; i++) { root = insert(root, values[i]); } int key = 40; Node* found = search(root, key); if (found != NULL) { printf(\"Key %d found in the BST.\\n\", key); } else { printf(\"Key %d not found in the BST.\\n\", key); } // Free memory allocated for the tree. freeTree(root); return 0; } . Explanation . | Node Structure: The Node structure represents nodes in the BST with an integer data and pointers to left and right children. | createNode Function: This helper function creates a new node with the given data and initializes its children to NULL. | insert Function: This function inserts a new value into the BST while maintaining the BST property. It recursively finds the appropriate position for the new node. | search Function: This is the core function that searches for a given key in the BST: . | If the current node is NULL, it means the key isn’t in the BST. | If the current node’s data matches the key, it returns a pointer to that node. | Otherwise, it recursively searches in the left or right subtree based on the comparison between the key and the node’s data. | . | freeTree Function: This utility function frees the allocated memory for the BST nodes to prevent memory leaks. | Main Function: The main function demonstrates constructing a BST by inserting a list of values, searching for a particular key, and then printing whether the key was found. Finally, it frees the memory used by the BST. | . This complete and self-contained example should help you understand how to search for a value in a binary search tree using C. ",
    "url": "/2025-03-03-C.html#example-code",
    
    "relUrl": "/2025-03-03-C.html#example-code"
  },"14": {
    "doc": "C",
    "title": "C",
    "content": " ",
    "url": "/2025-03-03-C.html",
    
    "relUrl": "/2025-03-03-C.html"
  },"15": {
    "doc": "Delphi/Object Pascal",
    "title": " Delphi/Object Pascal",
    "content": " ",
    "url": "/2025-03-03-Delphi-Object%20Pascal.html#-delphiobject-pascal",
    
    "relUrl": "/2025-03-03-Delphi-Object%20Pascal.html#-delphiobject-pascal"
  },"16": {
    "doc": "Delphi/Object Pascal",
    "title": "Official website",
    "content": "The official website for Delphi, which is developed and maintained by Embarcadero Technologies, is available here: https://www.embarcadero.com/products/delphi . This site provides details about the latest releases, features, and documentation for Delphi/Object Pascal. ",
    "url": "/2025-03-03-Delphi-Object%20Pascal.html#official-website",
    
    "relUrl": "/2025-03-03-Delphi-Object%20Pascal.html#official-website"
  },"17": {
    "doc": "Delphi/Object Pascal",
    "title": "Static typing",
    "content": "Yes, Delphi (Object Pascal) is a statically typed language. This means that the type of a variable is known at compile-time, which allows for early detection of type errors and can lead to optimizations in the generated code. A few points that further clarify this: . | Explicit Type Declarations: In Object Pascal, when you declare a variable, you’re typically required to specify its type. For example: . var Number: Integer; Greeting: string; . Here, the types of Number and Greeting are explicitly declared as Integer and string, respectively. | Compile-Time Type Checking: The compiler checks variable types during compilation. This means that if you try to assign a value of an incompatible type to a variable, the compiler will generate an error before the program is run. | Type Inference (Limited): Although Delphi is fundamentally statically typed, newer versions support some forms of type inference (particularly with anonymous methods and generics). However, the underlying type system remains static, ensuring that all types are known at compile time. | . In summary, Object Pascal is a statically typed language, which contributes to its robustness, helps catch errors early, and improves code performance through compile-time optimizations. ",
    "url": "/2025-03-03-Delphi-Object%20Pascal.html#static-typing",
    
    "relUrl": "/2025-03-03-Delphi-Object%20Pascal.html#static-typing"
  },"18": {
    "doc": "Delphi/Object Pascal",
    "title": "Example code",
    "content": "Below is an example of how you can implement a binary search tree (BST) search algorithm in Delphi/Object Pascal. In this example, we define a BST node record, a pointer type for nodes, and a function that recursively searches a value in the BST. program BSTSearchExample; {$APPTYPE CONSOLE} uses SysUtils; type // Define the record type for a BST node PTreeNode = ^TTreeNode; TTreeNode = record Value: Integer; Left, Right: PTreeNode; end; { Function: SearchBST Description: Recursively searches for a specified value in a binary search tree. Parameters: Root - pointer to the root node of the BST. Key - the integer value to search for. Returns: A pointer to the node containing the Key, or nil if the value is not found. } function SearchBST(Root: PTreeNode; Key: Integer): PTreeNode; begin if Root = nil then Exit(nil); // Tree is empty or reached end of branch if Root^.Value = Key then begin Exit(Root); // Found the key end else if Key &lt; Root^.Value then begin // Search in the left subtree Exit(SearchBST(Root^.Left, Key)); end else begin // Search in the right subtree Exit(SearchBST(Root^.Right, Key)); end; end; { Procedure: InsertNode Description: Inserts a new integer value into the BST. The tree is modified in place. Parameters: var Root - pointer to the root node of the BST. Value - the integer value to insert. } procedure InsertNode(var Root: PTreeNode; Value: Integer); begin if Root = nil then begin New(Root); Root^.Value := Value; Root^.Left := nil; Root^.Right := nil; end else if Value &lt; Root^.Value then begin InsertNode(Root^.Left, Value); end else begin InsertNode(Root^.Right, Value); end; end; { Procedure: FreeTree Description: Recursively free all nodes of the BST. Parameters: Root - pointer to the root node of the BST. } procedure FreeTree(Root: PTreeNode); begin if Root &lt;&gt; nil then begin FreeTree(Root^.Left); FreeTree(Root^.Right); Dispose(Root); end; end; var Root, FoundNode: PTreeNode; searchKey: Integer; begin Root := nil; // Insert some sample values into the BST InsertNode(Root, 50); InsertNode(Root, 30); InsertNode(Root, 70); InsertNode(Root, 20); InsertNode(Root, 40); InsertNode(Root, 60); InsertNode(Root, 80); Write('Enter a value to search: '); ReadLn(searchKey); FoundNode := SearchBST(Root, searchKey); if FoundNode &lt;&gt; nil then Writeln('Value ', searchKey, ' found in the BST.') else Writeln('Value ', searchKey, ' was not found in the BST.'); // Free the allocated nodes FreeTree(Root); ReadLn; end. Explanation . | Data Types and Node Structure: . | TTreeNode is a record representing a node in the BST. It contains an integer Value and two pointers (Left, Right) to its child nodes. | PTreeNode is a pointer to TTreeNode. | . | SearchBST Function: . | This function takes a pointer to the root of the tree and the desired search key. | It recursively navigates the tree: if the node is nil, it returns nil; if the node’s value matches the key, it returns the node; otherwise, it continues searching in the left or right subtree, depending on whether the key is less than or greater than the current node’s Value. | . | InsertNode Procedure: . | This procedure inserts a new node into the BST in the correct location to maintain BST properties. | . | FreeTree Procedure: . | Recursively deallocates all nodes in the BST to avoid memory leaks. | . | Main Program: . | Inserts sample nodes into the BST. | Asks the user for a value to search and calls SearchBST to retrieve information about the node. | Outputs whether the value was found or not. | Frees the tree memory before ending. | . | . This complete code is ready to compile and run in a Delphi environment. ",
    "url": "/2025-03-03-Delphi-Object%20Pascal.html#example-code",
    
    "relUrl": "/2025-03-03-Delphi-Object%20Pascal.html#example-code"
  },"19": {
    "doc": "Delphi/Object Pascal",
    "title": "Delphi/Object Pascal",
    "content": " ",
    "url": "/2025-03-03-Delphi-Object%20Pascal.html",
    
    "relUrl": "/2025-03-03-Delphi-Object%20Pascal.html"
  },"20": {
    "doc": "Fortran",
    "title": " Fortran",
    "content": " ",
    "url": "/2025-03-03-Fortran.html#-fortran",
    
    "relUrl": "/2025-03-03-Fortran.html#-fortran"
  },"21": {
    "doc": "Fortran",
    "title": "Official website",
    "content": "Fortran isn’t managed by a single centralized organization with a dedicated “official website” the way some languages are. Instead, the language standards for Fortran are developed and maintained by the ISO/IEC JTC1/SC22/WG5 working group. For information directly from the standards committee, you can visit the WG5 website: . https://wg5-fortran.org/ . This site provides details on the latest standards efforts, meeting information, and relevant documents. Additionally, for historical and general resources on Fortran you might also find the Fortran Wiki and pages hosted by various Fortran users’ groups useful. ",
    "url": "/2025-03-03-Fortran.html#official-website",
    
    "relUrl": "/2025-03-03-Fortran.html#official-website"
  },"22": {
    "doc": "Fortran",
    "title": "Static typing",
    "content": "Yes, Fortran is considered a statically typed language. This means that the type of every variable is determined at compile time, not at runtime. In Fortran, you typically declare the type of each variable explicitly. For example: . INTEGER :: i REAL :: x DOUBLE PRECISION :: y . Unless you specify otherwise, Fortran also applies implicit typing rules (based on variable names), which means that variables starting with certain letters (by default I-N) are assumed to be of type INTEGER and others as REAL. However, it’s a common best practice to disable this implicit behavior by including the statement “IMPLICIT NONE” at the beginning of your program or subroutine. This requires you to explicitly declare every variable, further reinforcing the static type system: . PROGRAM Example IMPLICIT NONE INTEGER :: count REAL :: value count = 5 value = 3.14 PRINT *, \"Count = \", count, \" Value = \", value END PROGRAM Example . In summary, Fortran’s type system is static because types are known and checked at compile time rather than being determined dynamically during execution. ",
    "url": "/2025-03-03-Fortran.html#static-typing",
    
    "relUrl": "/2025-03-03-Fortran.html#static-typing"
  },"23": {
    "doc": "Fortran",
    "title": "Example code",
    "content": "Below is an example implementation in Fortran 90 that defines a binary search tree (BST) data structure and includes an algorithm (a recursive function) to find whether a given integer value exists in the BST. In this example, the BST is built using dynamic pointers and a recursive search procedure. You can compile this code with a Fortran compiler (for example, gfortran). program bst_search implicit none ! Define a pointer-based binary search tree node as a derived type. type :: BSTNode integer :: value = -1 type(BSTNode), pointer :: left =&gt; null() type(BSTNode), pointer :: right =&gt; null() end type BSTNode type(BSTNode), pointer :: root =&gt; null() ! Local variables. integer :: value_to_find, search_result integer, dimension(7) :: data = [15, 10, 20, 8, 12, 17, 25] integer :: i ! Insert all data items into BST. do i = 1, size(data) call insert(root, data(i)) end do ! Ask user for input value to search. print *, \"Enter an integer value to find:\" read(*,*) value_to_find ! Search for the value in the BST. search_result = search(root, value_to_find) if (search_result == 1) then print *, \"Found the value \", value_to_find else print *, \"Value \", value_to_find, \" not found in the tree.\" end if contains !--------------------------------------------------------------------------- ! Recursive procedure to insert a new value into the BST. subroutine insert(node, new_value) type(BSTNode), pointer :: node integer, intent(in) :: new_value type(BSTNode), pointer :: newNode if (.not. associated(node)) then ! If current node pointer is not associated, allocate a new node. allocate(node) node%value = new_value node%left =&gt; null() node%right =&gt; null() else if (new_value &lt; node%value) then call insert(node%left, new_value) else if (new_value &gt; node%value) then call insert(node%right, new_value) else ! Duplicate value encountered; here we do nothing. end if end subroutine insert !--------------------------------------------------------------------------- ! Recursive function to search for a value in the BST. ! Returns 1 if found, 0 if not found. integer function search(node, key) result(found) type(BSTNode), pointer :: node integer, intent(in) :: key if (.not. associated(node)) then found = 0 else if (node%value == key) then found = 1 else if (key &lt; node%value) then found = search(node%left, key) else found = search(node%right, key) end if end function search end program bst_search . Explanation . | BSTNode Type Definition: The derived type BSTNode contains an integer value and two pointers (left and right) pointing to its child nodes. | Insertion Subroutine (insert): In the insert subroutine, if the pointer is not associated (i.e., the spot is empty), a new node is allocated. Otherwise, the procedure decides to insert either to the left or the right based on the BST property. | Search Function (search): The search function is a recursive function that checks the current node: . | If the node is not associated, the search has reached a dead end, and the function returns 0 (not found). | If the node’s value matches the search key, the function returns 1 (found). | If the key is less than the current node’s value, the function recurses into the left subtree; otherwise, into the right subtree. | . | Main Program: A sample BST is built with an array of integers. The code then reads a value from the user, searches for it in the BST, and prints whether the value was found. | . Compile and run this code, then follow the prompt to enter the integer to search for. This implementation demonstrates how to create and manipulate a BST in Fortran and how to perform a binary search within it. ",
    "url": "/2025-03-03-Fortran.html#example-code",
    
    "relUrl": "/2025-03-03-Fortran.html#example-code"
  },"24": {
    "doc": "Fortran",
    "title": "Fortran",
    "content": " ",
    "url": "/2025-03-03-Fortran.html",
    
    "relUrl": "/2025-03-03-Fortran.html"
  },"25": {
    "doc": "Go",
    "title": " Go",
    "content": " ",
    "url": "/2025-03-03-Go.html#-go",
    
    "relUrl": "/2025-03-03-Go.html#-go"
  },"26": {
    "doc": "Go",
    "title": "Official website",
    "content": "The official website for the Go programming language is https://golang.org. ",
    "url": "/2025-03-03-Go.html#official-website",
    
    "relUrl": "/2025-03-03-Go.html#official-website"
  },"27": {
    "doc": "Go",
    "title": "Static typing",
    "content": "Yes, Go is a statically typed language. This means that the type of every variable is known at compile time, which helps catch type errors before the code runs. While Go does have mechanisms like type inference (using the := syntax) that can automatically deduce types, the language is still fundamentally statically typed. ",
    "url": "/2025-03-03-Go.html#static-typing",
    
    "relUrl": "/2025-03-03-Go.html#static-typing"
  },"28": {
    "doc": "Go",
    "title": "Example code",
    "content": "Below is a complete Go program that defines a binary search tree, inserts values into it, and includes a function to find a value in the tree: . package main import ( \"fmt\" ) // TreeNode is a node in a binary search tree. type TreeNode struct { Value int Left *TreeNode Right *TreeNode } // Insert inserts a new value into the BST. func (node *TreeNode) Insert(value int) { if value &lt; node.Value { // Insert in the left subtree. if node.Left == nil { node.Left = &amp;TreeNode{Value: value} } else { node.Left.Insert(value) } } else if value &gt; node.Value { // Insert in the right subtree. if node.Right == nil { node.Right = &amp;TreeNode{Value: value} } else { node.Right.Insert(value) } } // If value == node.Value, we'll do nothing to avoid duplicates. } // Find searches for a value in the binary search tree. // It returns a pointer to the TreeNode if found, or nil if the value is not present. func (node *TreeNode) Find(value int) *TreeNode { if node == nil { return nil } if value == node.Value { return node } else if value &lt; node.Value { return node.Left.Find(value) } else { return node.Right.Find(value) } } func main() { // Create the BST with an initial root node. root := &amp;TreeNode{Value: 50} // Insert some values. values := []int{30, 70, 20, 40, 60, 80} for _, v := range values { root.Insert(v) } // Value to search for. target := 60 result := root.Find(target) if result != nil { fmt.Printf(\"Found node with value: %d\\n\", result.Value) } else { fmt.Printf(\"Value %d not found in the tree.\\n\", target) } } . Explanation . | TreeNode Structure: The TreeNode struct has an integer Value and pointers to the left and right children. | Insert Function: The Insert method recursively places a new integer into the binary search tree according to BST rules (left child is less than the parent, right child is greater than the parent). | Find Function: The Find method searches the tree recursively: . | If the current node is nil, the search terminates and returns nil. | If the searched value equals the node’s value, the node is returned. | Otherwise, the search continues in the left or right subtree depending on the value. | . | main Function: In the main function, a tree is created, populated with several values, and then a search is performed for a specific target value. The result is printed to the console. | . This implementation is a simple demonstration of binary search tree operations in Go. ",
    "url": "/2025-03-03-Go.html#example-code",
    
    "relUrl": "/2025-03-03-Go.html#example-code"
  },"29": {
    "doc": "Go",
    "title": "Go",
    "content": " ",
    "url": "/2025-03-03-Go.html",
    
    "relUrl": "/2025-03-03-Go.html"
  },"30": {
    "doc": "Java",
    "title": " Java",
    "content": " ",
    "url": "/2025-03-03-Java.html#-java",
    
    "relUrl": "/2025-03-03-Java.html#-java"
  },"31": {
    "doc": "Java",
    "title": "Official website",
    "content": "The official website for Java is: https://www.java.com . You can visit this site to download Java, access documentation, and find additional resources related to the Java programming language and platform. ",
    "url": "/2025-03-03-Java.html#official-website",
    
    "relUrl": "/2025-03-03-Java.html#official-website"
  },"32": {
    "doc": "Java",
    "title": "Static typing",
    "content": "Yes, Java is a statically typed language. This means that: . | Type Checking at Compile-Time: Variable types are determined at compile time. If you try to assign a value of the wrong type to a variable, the code will fail to compile. | Explicit Type Declarations: In Java, you must declare the type of a variable when it is created. For example: . int number = 5; String text = \"Hello\"; . | Early Error Detection: Statically typed languages like Java allow errors to be caught early in the development process rather than at runtime, which can help improve code reliability and maintainability. | . Overall, the static typing in Java contributes to robust code development through structured type enforcement and compile-time checking. ",
    "url": "/2025-03-03-Java.html#static-typing",
    
    "relUrl": "/2025-03-03-Java.html#static-typing"
  },"33": {
    "doc": "Java",
    "title": "Example code",
    "content": "Below is an example Java implementation of a binary search tree (BST) along with a method to search for a value within the tree. The algorithm takes advantage of the BST property—where for any given node, all values in the left subtree are smaller, and all values in the right subtree are larger than the node’s value—to decide whether to search left or right. This results in an efficient search with an average time complexity of O(log n). // Define the Binary Search Tree Node class class TreeNode { int value; TreeNode left; TreeNode right; TreeNode(int value) { this.value = value; left = null; right = null; } } // Define the Binary Search Tree class class BinarySearchTree { TreeNode root; BinarySearchTree() { root = null; } // Method to insert a new node into BST public void insert(int value) { root = insertRecursive(root, value); } private TreeNode insertRecursive(TreeNode node, int value) { if (node == null) { return new TreeNode(value); } if (value &lt; node.value) { node.left = insertRecursive(node.left, value); } else if (value &gt; node.value) { node.right = insertRecursive(node.right, value); } // if the value is equal, you can decide to do nothing or handle duplicates return node; } // Search method: returns true if value is found, false otherwise public boolean search(int target) { return searchRecursive(root, target); } private boolean searchRecursive(TreeNode node, int target) { if (node == null) { // Reached a leaf without finding the value return false; } if (node.value == target) { // Found the target value return true; } else if (target &lt; node.value) { // Target is less, search in left subtree return searchRecursive(node.left, target); } else { // Target is greater, search in right subtree return searchRecursive(node.right, target); } } } public class Main { public static void main(String[] args) { // Create a BinarySearchTree instance and add some values BinarySearchTree bst = new BinarySearchTree(); bst.insert(50); bst.insert(30); bst.insert(20); bst.insert(40); bst.insert(70); bst.insert(60); bst.insert(80); // Search for a value in the BST int target = 60; boolean found = bst.search(target); System.out.println(\"Value \" + target + (found ? \" found in\" : \" not found in\") + \" the BST.\"); // Search for another value target = 25; found = bst.search(target); System.out.println(\"Value \" + target + (found ? \" found in\" : \" not found in\") + \" the BST.\"); } } . Explanation . | TreeNode Class: . | Represents a node in the tree with an integer value and left/right child pointers. | . | BinarySearchTree Class: . | Contains the root of the BST and methods to insert values (insert and insertRecursive) and search for values (search and searchRecursive). | The insert method builds the tree by ensuring that for each node, values less than the node go to the left, and those greater go to the right. | The searchRecursive method works by comparing the target with the current node’s value. Based on the comparison, it decides whether to continue search in the left or right subtree, terminating when the value is found or when a null pointer is reached. | . | Main Class: . | Demonstrates how to create a BST, insert values, and search for specific values. | . | . You can compile and run this Java code to see how the algorithm works. ",
    "url": "/2025-03-03-Java.html#example-code",
    
    "relUrl": "/2025-03-03-Java.html#example-code"
  },"34": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "/2025-03-03-Java.html",
    
    "relUrl": "/2025-03-03-Java.html"
  },"35": {
    "doc": "JavaScript",
    "title": " JavaScript",
    "content": " ",
    "url": "/2025-03-03-JavaScript.html#-javascript",
    
    "relUrl": "/2025-03-03-JavaScript.html#-javascript"
  },"36": {
    "doc": "JavaScript",
    "title": "Official website",
    "content": "JavaScript itself doesn’t have a single “official website” in the way that some languages (or projects) do. Instead, JavaScript is standardized as ECMAScript, and its specifications are maintained by Ecma International. Here are a couple of important resources: . | ECMAScript Specifications: The official ECMAScript website by Ecma International contains the standards and technical details about the language. Link: https://www.ecma-international.org/ . | MDN Web Docs: For comprehensive documentation, tutorials, and guides on JavaScript (along with web technologies), the MDN Web Docs provided by Mozilla is widely regarded as one of the best resources. Link: https://developer.mozilla.org/en-US/docs/Web/JavaScript . | . Depending on what you’re looking for—a formal specification or documentation and learning resources—you might choose one of these links. ",
    "url": "/2025-03-03-JavaScript.html#official-website",
    
    "relUrl": "/2025-03-03-JavaScript.html#official-website"
  },"37": {
    "doc": "JavaScript",
    "title": "Static typing",
    "content": "No, JavaScript is not statically typed—it is dynamically typed. This means that in JavaScript, data types are determined at runtime, and you can assign a value of any type to a variable without specifying the type in advance. For instance: . let example = 42; // example is initially a number example = \"hello\"; // now example holds a string . In contrast, statically typed languages (such as Java, C#, or even TypeScript, which is a superset of JavaScript) require variables to have a declared type at compile time, allowing the compiler to catch type-related errors before the program runs. If you’re interested in adding static typing to JavaScript code, you might explore TypeScript or Flow, which offer optional type annotations that can help catch type errors early in the development process. ",
    "url": "/2025-03-03-JavaScript.html#static-typing",
    
    "relUrl": "/2025-03-03-JavaScript.html#static-typing"
  },"38": {
    "doc": "JavaScript",
    "title": "Example code",
    "content": "Below is one way to implement a function to search for a value in a binary search tree using JavaScript. In this example, we’ll define a simple Node class to represent tree nodes and then implement a recursive search function. The function returns the node containing the value if it’s found, or null otherwise. // Define a Node class for a binary search tree. class Node { constructor(value) { this.value = value; this.left = null; this.right = null; } } // Recursive function to search for a value in a binary search tree. function searchBST(root, target) { // Base case: Empty tree or node is found. if (root === null) { return null; } if (root.value === target) { return root; } // If target is less than the current node's value, search left if (target &lt; root.value) { return searchBST(root.left, target); } else { // Otherwise, search right return searchBST(root.right, target); } } // To test the algorithm, let's build a sample binary search tree: function insertNode(root, value) { if (root === null) { return new Node(value); } if (value &lt; root.value) { root.left = insertNode(root.left, value); } else if (value &gt; root.value) { root.right = insertNode(root.right, value); } // For duplicate values, do nothing or handle as needed return root; } // Create a binary search tree. let root = null; const values = [50, 30, 70, 20, 40, 60, 80]; values.forEach(value =&gt; { root = insertNode(root, value); }); // Test the searchBST function. const target = 60; const result = searchBST(root, target); if (result !== null) { console.log(`Found node with value: ${result.value}`); } else { console.log(`Value ${target} not found in the BST.`); } . Explanation . | Node class: Each node stores a value and pointers to its left and right children. | searchBST function: . | If the current node is null, return null (target not found). | If the current node’s value is equal to the target, return the node. | If the target is less than the current node’s value, recursively search the left subtree; if greater, search the right subtree. | . | insertNode function: This helper function inserts a new value into the tree, maintaining the binary search tree property. This is used to build the tree for testing. | Testing: The code builds a BST with the specified values and then searches for the value 60, printing the result. | . This implementation is a straightforward example of how to search within a binary search tree in JavaScript. ",
    "url": "/2025-03-03-JavaScript.html#example-code",
    
    "relUrl": "/2025-03-03-JavaScript.html#example-code"
  },"39": {
    "doc": "JavaScript",
    "title": "JavaScript",
    "content": " ",
    "url": "/2025-03-03-JavaScript.html",
    
    "relUrl": "/2025-03-03-JavaScript.html"
  },"40": {
    "doc": "PHP",
    "title": " PHP",
    "content": " ",
    "url": "/2025-03-03-PHP.html#-php",
    
    "relUrl": "/2025-03-03-PHP.html#-php"
  },"41": {
    "doc": "PHP",
    "title": "Official website",
    "content": "The official website for PHP is https://www.php.net. ",
    "url": "/2025-03-03-PHP.html#official-website",
    
    "relUrl": "/2025-03-03-PHP.html#official-website"
  },"42": {
    "doc": "PHP",
    "title": "Static typing",
    "content": "PHP is primarily a dynamically typed language. This means that variable types are determined at runtime rather than at compile-time. You don’t have to explicitly declare the type of a variable when you assign it, and the type can change during the execution of a program. However, over the years, PHP has introduced features that bring in some benefits of static typing: . | Type Declarations: Since PHP 7, you can declare scalar types and return types for functions and methods. This means you can specify that a function expects, for example, an integer or a string as an argument, or that it should return a certain type. &lt;?php declare(strict_types=1); function addNumbers(int $num1, int $num2): int { return $num1 + $num2; } echo addNumbers(2, 3); // Outputs: 5 ?&gt; . | Class Property Types: Starting with PHP 7.4, you can also type-hint class properties. This adds an additional layer of type safety within objects. &lt;?php class User { public string $name; public int $age; } $user = new User(); $user-&gt;name = \"Alice\"; $user-&gt;age = 30; ?&gt; . | Union Types and More: PHP 8.0 introduced union types, and PHP 8.1 has brought in features like readonly properties which further enhance the type system. | . Despite these improvements, PHP does not enforce type checks as strictly as some statically typed languages like Java or C#. The type declarations are optional enhancements rather than inherent characteristics of how the language operates. In summary, while PHP now supports optional type declarations and features that align with static typing principles, it remains a dynamically typed language by design. ",
    "url": "/2025-03-03-PHP.html#static-typing",
    
    "relUrl": "/2025-03-03-PHP.html#static-typing"
  },"43": {
    "doc": "PHP",
    "title": "Example code",
    "content": "Below is a sample PHP implementation of a binary search tree (BST) along with an algorithm to find a value in it. In this example, we define a Node class to represent each node of the BST and a BST class with an insert method to populate the tree and a search method to find a specific value. &lt;?php // Node class representing each node of the binary search tree class Node { public $value; public $left; public $right; public function __construct($value) { $this-&gt;value = $value; $this-&gt;left = null; $this-&gt;right = null; } } // Binary Search Tree (BST) class class BinarySearchTree { public $root; public function __construct() { $this-&gt;root = null; } // Insert a new value into the BST public function insert($value) { $newNode = new Node($value); if ($this-&gt;root === null) { $this-&gt;root = $newNode; return; } $current = $this-&gt;root; while (true) { if ($value &lt; $current-&gt;value) { if ($current-&gt;left === null) { $current-&gt;left = $newNode; return; } $current = $current-&gt;left; } else { if ($current-&gt;right === null) { $current-&gt;right = $newNode; return; } $current = $current-&gt;right; } } } // Find a node by value using binary search public function search($value) { $current = $this-&gt;root; while ($current !== null) { if ($value === $current-&gt;value) { // Value found return $current; } // Navigate left or right depending on the comparison if ($value &lt; $current-&gt;value) { $current = $current-&gt;left; } else { $current = $current-&gt;right; } } // Value not found return null; } } // Example of usage // Create a new binary search tree $bst = new BinarySearchTree(); // Insert values into the tree $values = [50, 30, 70, 20, 40, 60, 80]; foreach ($values as $value) { $bst-&gt;insert($value); } // Search for a value in the BST $searchValue = 60; $result = $bst-&gt;search($searchValue); if ($result !== null) { echo \"Value \" . $searchValue . \" found in the binary search tree.\"; } else { echo \"Value \" . $searchValue . \" not found in the binary search tree.\"; } ?&gt; . Explanation . | Node Class: The Node class represents each node in the BST with a value and two child pointers (left and right). | BinarySearchTree Class: This class is used to create and manage the BST. | The insert() method adds nodes to the BST, placing smaller values on the left subtree and larger values on the right subtree. | The search() method iteratively checks each node starting from the root. It uses the BST property to decide whether to continue searching to the left or right. If the node with the given value is found, it is returned; otherwise, the function returns null. | . | Usage Example: . | A new BST is created. | Values are inserted into the BST. | The algorithm then searches for a value (in this case, 60) and prints whether the value was found. | . | . This code should work as expected in a PHP environment. ",
    "url": "/2025-03-03-PHP.html#example-code",
    
    "relUrl": "/2025-03-03-PHP.html#example-code"
  },"44": {
    "doc": "PHP",
    "title": "PHP",
    "content": " ",
    "url": "/2025-03-03-PHP.html",
    
    "relUrl": "/2025-03-03-PHP.html"
  },"45": {
    "doc": "Python",
    "title": " Python",
    "content": " ",
    "url": "/2025-03-03-Python.html#-python",
    
    "relUrl": "/2025-03-03-Python.html#-python"
  },"46": {
    "doc": "Python",
    "title": "Official website",
    "content": "The official website for Python is https://www.python.org. ",
    "url": "/2025-03-03-Python.html#official-website",
    
    "relUrl": "/2025-03-03-Python.html#official-website"
  },"47": {
    "doc": "Python",
    "title": "Static typing",
    "content": "Python is not statically typed; it is dynamically typed. This means that types are determined at runtime rather than during compile time. In Python, you don’t need to explicitly declare variable types before assigning values, and a variable can be reassigned to objects of different types during execution. However, Python does support type hints (introduced in Python 3.5 with PEP 484) that allow developers to optionally annotate variables and function signatures with type information. These annotations can help with code readability, and can be checked by static analysis tools (like mypy), but they are not enforced at runtime by the Python interpreter. ",
    "url": "/2025-03-03-Python.html#static-typing",
    
    "relUrl": "/2025-03-03-Python.html#static-typing"
  },"48": {
    "doc": "Python",
    "title": "Example code",
    "content": "Below is a Python implementation of a binary search tree (BST) along with a function to find (search for) a value in the tree. The code includes a Node class to represent each node in the BST and a recursive search function that exploits the BST property (i.e., left child nodes are less than the parent node, and right child nodes are greater). class Node: def __init__(self, key): self.key = key self.left = None self.right = None def insert(root, key): \"\"\" Inserts a new key into the binary search tree. Returns the new root after insertion. \"\"\" if root is None: return Node(key) if key &lt; root.key: root.left = insert(root.left, key) elif key &gt; root.key: root.right = insert(root.right, key) # Duplicate keys are not inserted return root def search(root, target): \"\"\" Searches for a target value in the binary search tree. Returns the node containing the target value, or None if the target does not exist. \"\"\" if root is None: # Target not found in BST return None if root.key == target: return root elif target &lt; root.key: return search(root.left, target) else: return search(root.right, target) # Example usage if __name__ == \"__main__\": # Construct the BST by inserting keys values = [50, 30, 70, 20, 40, 60, 80] bst_root = None for value in values: bst_root = insert(bst_root, value) # Search for specific values in the BST target_value = 40 result = search(bst_root, target_value) if result: print(f\"Found node with key: {result.key}\") else: print(f\"Key {target_value} not found in the BST.\") # Try searching for a value that does not exist target_value = 100 result = search(bst_root, target_value) if result: print(f\"Found node with key: {result.key}\") else: print(f\"Key {target_value} not found in the BST.\") . Explanation . | Node Class: . | Each Node has a key as its value and two child pointers left and right. | . | insert Function: . | The insert function adds a new key into the BST following the BST properties. | If the root is None, it creates a new node. | If the key is less than the current node’s key, it goes to the left subtree; if greater, it goes to the right subtree. | . | search Function: . | The search function looks for the target value. | It returns the node if the key matches. | Otherwise, it recursively searches the left or right subtree according to the BST property. | . | Example Usage: . | A small BST is constructed by inserting integer values. | The algorithm searches for a few example keys and reports the results accordingly. | . | . This implementation is complete, runnable, and demonstrates both insertion and search functionalities on a BST. ",
    "url": "/2025-03-03-Python.html#example-code",
    
    "relUrl": "/2025-03-03-Python.html#example-code"
  },"49": {
    "doc": "Python",
    "title": "Python",
    "content": " ",
    "url": "/2025-03-03-Python.html",
    
    "relUrl": "/2025-03-03-Python.html"
  },"50": {
    "doc": "Rust",
    "title": " Rust",
    "content": " ",
    "url": "/2025-03-03-Rust.html#-rust",
    
    "relUrl": "/2025-03-03-Rust.html#-rust"
  },"51": {
    "doc": "Rust",
    "title": "Official website",
    "content": "The official website for Rust is https://www.rust-lang.org. ",
    "url": "/2025-03-03-Rust.html#official-website",
    
    "relUrl": "/2025-03-03-Rust.html#official-website"
  },"52": {
    "doc": "Rust",
    "title": "Static typing",
    "content": "Yes, Rust is a statically typed language. This means that variable types are known at compile time, and most type checks are performed when you build your program rather than at runtime. However, Rust also offers type inference, which lets the compiler automatically deduce the types of many variables based on their usage, reducing the need for explicit type annotations while still retaining the benefits of static type checking. ",
    "url": "/2025-03-03-Rust.html#static-typing",
    
    "relUrl": "/2025-03-03-Rust.html#static-typing"
  },"53": {
    "doc": "Rust",
    "title": "Example code",
    "content": "Below is an example Rust program that defines a binary search tree (BST) and includes a function to search for a value within the tree. The code defines a BST using enum-based nodes, implements insertion (to build the tree), and a search function. You can run this complete example. #[derive(Debug)] enum BST { Empty, Node { value: i32, left: Box&lt;BST&gt;, right: Box&lt;BST&gt;, }, } impl BST { // Create an empty BST fn new() -&gt; Self { BST::Empty } // Insert a value into the BST fn insert(self, val: i32) -&gt; Self { match self { BST::Empty =&gt; BST::Node { value: val, left: Box::new(BST::Empty), right: Box::new(BST::Empty), }, BST::Node { value, left, right } =&gt; { if val &lt; value { BST::Node { value, left: Box::new(left.insert(val)), right, } } else if val &gt; value { BST::Node { value, left, right: Box::new(right.insert(val)), } } else { // Value already exists, do nothing. BST::Node { value, left, right } } } } } // Search for a value in the BST fn find(&amp;self, val: i32) -&gt; bool { match self { BST::Empty =&gt; false, BST::Node { value, left, right } =&gt; { if *value == val { true } else if val &lt; *value { left.find(val) } else { right.find(val) } } } } } fn main() { // Create a BST and insert some values let bst = BST::new() .insert(15) .insert(10) .insert(20) .insert(8) .insert(12) .insert(17) .insert(25); // Search for a few values for key in [10, 15, 25, 99] { if bst.find(key) { println!(\"Found {}\", key); } else { println!(\"Did not find {}\", key); } } } . Explanation . | BST Definition: The BST is defined as an enum that represents either an empty tree (Empty) or a node (Node) containing a value and left/right subtrees. | Insertion: The insert method takes ownership of the tree and returns a new tree with the inserted value. It recursively inserts the value in the correct position according to BST properties. | Searching: The find method checks whether a given value exists in the tree. It recursively navigates left or right based on comparisons. | Main Function: A BST is created and populated with several values, and then some values are searched within the tree, printing the result to the console. | . Feel free to compile and run this code with Cargo or rustc. ",
    "url": "/2025-03-03-Rust.html#example-code",
    
    "relUrl": "/2025-03-03-Rust.html#example-code"
  },"54": {
    "doc": "Rust",
    "title": "Rust",
    "content": " ",
    "url": "/2025-03-03-Rust.html",
    
    "relUrl": "/2025-03-03-Rust.html"
  },"55": {
    "doc": "SQL",
    "title": " SQL",
    "content": " ",
    "url": "/2025-03-03-SQL.html#-sql",
    
    "relUrl": "/2025-03-03-SQL.html#-sql"
  },"56": {
    "doc": "SQL",
    "title": "Official website",
    "content": "SQL (Structured Query Language) is not managed or owned by a single organization, so there isn’t a singular “official website of SQL.” Instead, SQL is a standardized language governed by: . • ANSI (American National Standards Institute) – ANSI is responsible for the SQL standard in the United States. You can find more information about ANSI standards at the ANSI website: ANSI Webstore. • ISO (International Organization for Standardization) – ISO publishes the international standards for SQL (e.g., ISO/IEC 9075). You can browse ISO standards on their website: ISO Website. For general reference and an overview of SQL, the Wikipedia page can also serve as a useful resource: SQL on Wikipedia. If you are looking for documentation or further information on a particular SQL dialect (such as T-SQL for Microsoft SQL Server, PL/SQL for Oracle, or PostgreSQL’s SQL language), it would be best to visit the official website of the respective vendor or community. ",
    "url": "/2025-03-03-SQL.html#official-website",
    
    "relUrl": "/2025-03-03-SQL.html#official-website"
  },"57": {
    "doc": "SQL",
    "title": "Static typing",
    "content": "SQL’s type system can be a bit nuanced and depends on the context and the specific SQL dialect or database management system (DBMS) in use. Here are some key points to consider: . | Column Types in SQL: Standard SQL requires that each column in a table be declared with a data type (e.g., INTEGER, VARCHAR, DATE). This design implies that SQL is statically typed in the sense that the schema is defined with explicit types and they guide how data is stored, compared, and manipulated. | Compile‑time vs. Run‑time Type Checking: . | In many compiled or interpreted SQL environments (for example, when running queries against systems like PostgreSQL, MySQL, Oracle, or SQL Server), the DBMS checks the compatibility of data types during query parsing or planning. This means that many type mismatches are caught before the query actually runs, which is a property of static typing. | However, some SQL systems perform type checks or coercions at runtime, and certain operations can involve implicit type conversion. This behavior may give the impression of more dynamic type handling. | . | Variations Among Implementations: . | Strictly Statically Typed Systems: Many mainstream relational databases enforce strict type checking and will reject data that does not conform to the declared type. They also enforce type compatibility rules when performing operations on column values. | Systems with Dynamic Typing Aspects: Some databases, notably SQLite, use a concept called “type affinity.” In SQLite, you still define a column with a suggested type, but the engine is more permissive and may store a value of a different type than the declared type. This behavior resembles dynamic typing in some respects, although many SQL language constructs still treat types in a mostly static way. | . | Summary: . | In the traditional SQL sense, SQL is considered to be statically typed because schemas require explicit type definitions and many systems enforce type rules during query planning. | However, behaviors such as implicit type conversion and, in some cases (like SQLite), more relaxed type affinity rules, introduce elements that can seem dynamically typed. | . | . So, while the SQL standard and many common relational databases follow a statically typed architecture, there are notable exceptions and behaviors that can blur this distinction depending on the system you are using. ",
    "url": "/2025-03-03-SQL.html#static-typing",
    
    "relUrl": "/2025-03-03-SQL.html#static-typing"
  },"58": {
    "doc": "SQL",
    "title": "Example code",
    "content": "Assume you have a table representing your binary search tree structured like this: . | id: Unique identifier for the node. | value: The actual value stored in the node. | left_id: References the left child node (or is NULL if none). | right_id: References the right child node (or is NULL if none). | . For example: . CREATE TABLE bst ( id INTEGER PRIMARY KEY, value INTEGER NOT NULL, left_id INTEGER, right_id INTEGER, CONSTRAINT fk_left FOREIGN KEY (left_id) REFERENCES bst(id), CONSTRAINT fk_right FOREIGN KEY (right_id) REFERENCES bst(id) ); . To find a given search value in the binary search tree using a recursive algorithm in SQL, you can use a recursive common table expression (CTE). Below is an example query. In this example, we assume: . | The root node’s id is known (for example, 1). | The search value is provided via a parameter (for example, @search_value). | . WITH RECURSIVE search_tree AS ( -- Start with the root node; adjust the id if your root is different. SELECT id, value, left_id, right_id FROM bst WHERE id = 1 -- assuming root node id is 1 UNION ALL -- Recursively traverse the tree. SELECT bst.id, bst.value, bst.left_id, bst.right_id FROM bst JOIN search_tree st ON ( -- Decide which child to join on depending on the search value. (st.value &gt; @search_value AND bst.id = st.left_id) OR (st.value &lt; @search_value AND bst.id = st.right_id) ) ) SELECT * FROM search_tree WHERE value = @search_value; . How It Works . | Anchor member: The CTE starts with the root node (where id = 1). Adjust this if your root’s id differs. | Recursive member: For each node in the current result set (search_tree), we join back to the bst table. | If the current node’s value is greater than the search value, the join condition looks for a match on the left child (left_id). | If the current node’s value is less than the search value, it looks for a match on the right child (right_id). | . | Final selection: The final SELECT statement picks the record(s) where the value equals the @search_value. If the value exists in the tree, it will be returned; otherwise, the query returns no rows. | . Notes . | Replace @search_value with the actual search number or bind it as a parameter from your application. | Ensure your SQL dialect supports recursive CTEs (most modern RDBMSs like PostgreSQL, SQL Server, and SQLite do). | This algorithm assumes that every value in the BST is unique. If duplicates are allowed, you might need to adjust the logic accordingly. | . This algorithm mimics the binary-search process by traversing only the branch that could contain the value based on comparisons at each node. ",
    "url": "/2025-03-03-SQL.html#example-code",
    
    "relUrl": "/2025-03-03-SQL.html#example-code"
  },"59": {
    "doc": "SQL",
    "title": "SQL",
    "content": " ",
    "url": "/2025-03-03-SQL.html",
    
    "relUrl": "/2025-03-03-SQL.html"
  },"60": {
    "doc": "Scratch",
    "title": " Scratch",
    "content": " ",
    "url": "/2025-03-03-Scratch.html#-scratch",
    
    "relUrl": "/2025-03-03-Scratch.html#-scratch"
  },"61": {
    "doc": "Scratch",
    "title": "Official website",
    "content": "The official website of Scratch is accessible at: https://scratch.mit.edu . ",
    "url": "/2025-03-03-Scratch.html#official-website",
    
    "relUrl": "/2025-03-03-Scratch.html#official-website"
  },"62": {
    "doc": "Scratch",
    "title": "Static typing",
    "content": "Scratch is not statically typed. In Scratch: . | Dynamic Nature: You can assign any value to a variable without declaring its type beforehand. Variables can hold numbers, text, or other types of data without type restrictions. | No Type Enforcement: There is no compile-time type checking. Instead, any type-related issues are typically handled (or avoided) at runtime. | Designed for Simplicity: The language is designed to be accessible for beginners, so its flexible handling of data types is intentional. | . Thus, Scratch is considered dynamically typed, not statically typed. ",
    "url": "/2025-03-03-Scratch.html#static-typing",
    
    "relUrl": "/2025-03-03-Scratch.html#static-typing"
  },"63": {
    "doc": "Scratch",
    "title": "Example code",
    "content": "Below is one way to design an algorithm in Scratch that implements a search for a value in a binary search tree. In this example, we assume that your binary search tree is represented by lists (arrays) that store node information. One common approach is to represent each node as a “record” (using parallel lists or a list of lists) containing the following properties: . • Value (the node’s number or data) • Left child pointer (e.g., the index of the left child node in the list, or −1/0 if none) • Right child pointer (similar to left child) . For the purposes of this algorithm, we assume you have these variables or lists set up: . | A list called “nodes” where each item is a node record. (In Scratch, you could simulate a record using multiple lists that use the same index for corresponding properties. For example, “node_values,” “left_child,” and “right_child.”) | A variable called “target” (the value you are searching for). | A variable called “current” which will hold the current node’s index. | A special value (for example, -1) to signal “no child.” | . Below is an explanation using the parallel lists approach. Adjust according to your tree structure: . ────────────────────────────── Assumptions (setup): ────────────────────────────── Assume the following lists exist: . | node_values | left_child | right_child | . Each node is stored at some index i in these lists: . | The value is at node_values[i]. | The index of the left child is at left_child[i], or -1 if none. | The index of the right child is at right_child[i], or -1 if none. | . Assume the root node is at index 1. ────────────────────────────── Algorithm Overview: ────────────────────────────── We repeat the following until we either find the target or hit a leaf node: . | Start at the root (set current index to 1). | Compare target with node_values[current]. a. If equal, the target is found. b. If target &lt; node_values[current], then move to the left child using left_child[current]. c. If target &gt; node_values[current], then move to the right child using right_child[current]. | If at any point current becomes -1, then the target is not found. | . ────────────────────────────── The Scratch Blocks Algorithm: ────────────────────────────── Below is a step-by-step description that you can implement with Scratch blocks. You can use “if … then … else” blocks, “repeat until” blocks, and “set” blocks. | Initialize: . | Set [current v] to 1 (This assumes the root of your binary search tree is stored at index 1 in the lists.) | . | Use a repeating loop that continues until either a match is found or there is no node: . | Use a “repeat until” block with the condition: &lt;(current) = -1 or (node_values[current] = target)&gt; | . | Inside the loop: a. Check if node_values[current] equals target: . | Use an “if” block: If &lt;(item (current) of [node_values]) = (target)&gt; then • Broadcast message “Found” (or set a variable “found” to 1, etc.) • Stop this script (using “stop block” or “stop script”) | Else (the target is not equal) choose direction: . | If &lt;(target) &lt; (item (current) of [node_values])&gt; then • Set [current v] to (item (current) of [left_child]) | Else (target is greater than current value) • Set [current v] to (item (current) of [right_child]) | . | . | After the loop ends, check if current = -1: . | If yes, then broadcast “Not Found” or otherwise signal that the target was not located. | . | . ────────────────────────────── Pseudocode in Scratch-style: ────────────────────────────── Below is a combined pseudocode representation. In Scratch, you will have to design your sprites and scripts accordingly: . when green flag clicked set [current v] to [1] set [target v] to (desired value) // e.g., ask “Enter target:” and wait for answer set [found v] to [0] . repeat until &lt;(current) = [-1] or &lt;(item (current) of [node_values]) = (target)» if &lt;(item (current) of [node_values]) = (target)&gt; then set [found v] to [1] say [Value found at node (current)!] for (2) seconds stop [this script v] else if &lt;(target) &lt; (item (current) of [node_values])&gt; then set [current v] to (item (current) of [left_child]) else set [current v] to (item (current) of [right_child]) end end end . if &lt;(current) = [-1]&gt; then say [Value not found in the tree!] for (2) seconds end ——————————————————— . ────────────────────────────── Notes: ────────────────────────────── ● Make sure your lists “node_values,” “left_child,” and “right_child” are pre-populated with your binary search tree data. ● The indices in your lists in Scratch start at 1, so adjust accordingly when you fill the lists. ● You can customize how you notify the user (e.g., using “say” blocks or changing a variable). This algorithm efficiently searches the binary search tree by deciding at each node whether to continue to the left child (for smaller values) or the right child (for larger values), mimicking the binary search approach. Enjoy coding your solution in Scratch! . ",
    "url": "/2025-03-03-Scratch.html#example-code",
    
    "relUrl": "/2025-03-03-Scratch.html#example-code"
  },"64": {
    "doc": "Scratch",
    "title": "Scratch",
    "content": " ",
    "url": "/2025-03-03-Scratch.html",
    
    "relUrl": "/2025-03-03-Scratch.html"
  },"65": {
    "doc": "Visual Basic",
    "title": " Visual Basic",
    "content": " ",
    "url": "/2025-03-03-Visual%20Basic.html#-visual-basic",
    
    "relUrl": "/2025-03-03-Visual%20Basic.html#-visual-basic"
  },"66": {
    "doc": "Visual Basic",
    "title": "Official website",
    "content": "The official resources for Visual Basic are hosted by Microsoft. You can start with the Visual Basic section on Microsoft’s .NET documentation: . Visual Basic .NET Documentation on Microsoft Learn . This site provides comprehensive official information, tutorials, and references for Visual Basic. ",
    "url": "/2025-03-03-Visual%20Basic.html#official-website",
    
    "relUrl": "/2025-03-03-Visual%20Basic.html#official-website"
  },"67": {
    "doc": "Visual Basic",
    "title": "Static typing",
    "content": "The answer depends on which version of Visual Basic you are referring to: . | Visual Basic .NET (VB.NET): VB.NET is generally considered a statically typed language. This means that each variable must have a type that is determined at compile time. However, by default, VB.NET allows some flexibility due to features such as type inference (introduced in later versions) and the ability to disable strict type checking by using the “Option Strict Off” directive. When “Option Strict” is on—which is recommended for safer, more predictable code—the type of every variable is known at compile time, and implicit data type conversions are limited to those that are safe, making the language statically typed. | Earlier Versions of Visual Basic (such as VB6): Older versions of Visual Basic (like VB6) are not strictly statically typed. They were designed to be more flexible and provide a degree of dynamic typing. For example, variables were often declared as type Variant, which allowed them to hold any type of data at runtime. This made earlier Visual Basic versions less strictly statically typed compared to VB.NET. | . In summary: . | Visual Basic .NET (with Option Strict On) is a statically typed language. | Older versions of Visual Basic were more dynamically typed. ",
    "url": "/2025-03-03-Visual%20Basic.html#static-typing",
    
    "relUrl": "/2025-03-03-Visual%20Basic.html#static-typing"
  },"68": {
    "doc": "Visual Basic",
    "title": "Example code",
    "content": "Below is an example of a Visual Basic algorithm to search for a specific value within a binary search tree. In this example, we define a simple Binary Search Tree node class, then implement a recursive method to search for the value. You can paste this code into a Visual Basic project (such as a Console Application) and run it. | . Module Module1 ' Class representing a node in the binary search tree. Public Class TreeNode Public Property Value As Integer Public Property Left As TreeNode Public Property Right As TreeNode ' Constructor to initialize the node with a value. Public Sub New(ByVal value As Integer) Me.Value = value Me.Left = Nothing Me.Right = Nothing End Sub End Class ' Function to search for a value in the binary search tree. Public Function SearchBST(ByVal root As TreeNode, ByVal target As Integer) As Boolean ' If the current node is null, then the target is not found. If root Is Nothing Then Return False End If ' Check if the current node matches the target. If root.Value = target Then Return True End If ' If the target is less than the current node's value, search in the left subtree. If target &lt; root.Value Then Return SearchBST(root.Left, target) Else ' Otherwise, search in the right subtree. Return SearchBST(root.Right, target) End If End Function ' A helper function to insert a new value into the BST. Public Function InsertBST(ByVal root As TreeNode, ByVal value As Integer) As TreeNode If root Is Nothing Then Return New TreeNode(value) ElseIf value &lt; root.Value Then root.Left = InsertBST(root.Left, value) Else root.Right = InsertBST(root.Right, value) End If Return root End Function Sub Main() ' Create a binary search tree: Dim root As TreeNode = Nothing Dim values() As Integer = {50, 30, 70, 20, 40, 60, 80} ' Insert values into the BST. For Each val As Integer In values root = InsertBST(root, val) Next ' Define a target value to search for. Dim targetValue As Integer = 60 ' Search the BST for the target value. Dim found As Boolean = SearchBST(root, targetValue) ' Display the result. If found Then Console.WriteLine(\"Value \" &amp; targetValue &amp; \" found in the binary search tree.\") Else Console.WriteLine(\"Value \" &amp; targetValue &amp; \" not found in the binary search tree.\") End If Console.WriteLine(\"Press any key to exit...\") Console.ReadKey() End Sub End Module . Explanation . | TreeNode Class: This class holds the value and pointers to the left and right children. | SearchBST Function: This function takes the tree root and the target value as parameters. | It first checks if the current node is Nothing (indicating that the tree or subtree is empty) and returns False. | It then compares the current node’s value with the target. | If the current node’s value is greater than the target, the function calls itself recursively on the left subtree; otherwise, it searches the right subtree. | . | InsertBST Function: This helper function is used to build the tree by recursively finding the correct location to insert a new value. | Main Subroutine: The Main routine populates the binary search tree with example values and then searches for a specific target value. The result is printed to the console. | . You can modify the example values and target value as needed. This implementation assumes a BST where duplicate values are not allowed. ",
    "url": "/2025-03-03-Visual%20Basic.html#example-code",
    
    "relUrl": "/2025-03-03-Visual%20Basic.html#example-code"
  },"69": {
    "doc": "Visual Basic",
    "title": "Visual Basic",
    "content": " ",
    "url": "/2025-03-03-Visual%20Basic.html",
    
    "relUrl": "/2025-03-03-Visual%20Basic.html"
  },"70": {
    "doc": "Assembly language",
    "title": " Assembly language",
    "content": " ",
    "url": "/2025-03-04-Assembly%20language.html#-assembly-language",
    
    "relUrl": "/2025-03-04-Assembly%20language.html#-assembly-language"
  },"71": {
    "doc": "Assembly language",
    "title": "Official website",
    "content": "“Assembly language” refers to a category of low-level programming languages rather than a single language with one governing, official website. Each assembly language is generally specific to a processor architecture or developed by a particular vendor. For example: . | x86 Assembly: . | There isn’t one “official” website for x86 assembly as a whole. However, you might want to check out resources from Intel or AMD. • Intel’s manuals: Intel® 64 and IA-32 Architectures Software Developer Manuals • AMD’s manuals: AMD Developer Guides and Manuals | . | MASM (Microsoft Macro Assembler): . | You can find official Microsoft documentation on MASM as part of their development tools: Microsoft MASM documentation | . | NASM (Netwide Assembler): . | NASM is an open-source assembler, and you can visit its official website: NASM Official Website | . | . If you were referring to a general resource or a specific assembly language version, please let me know so I can point you toward the most relevant official website or documentation. ",
    "url": "/2025-03-04-Assembly%20language.html#official-website",
    
    "relUrl": "/2025-03-04-Assembly%20language.html#official-website"
  },"72": {
    "doc": "Assembly language",
    "title": "Static typing",
    "content": "Assembly language is generally considered to be untyped rather than statically typed. Here’s why: . | Lack of Type System: Assembly language operates very close to the hardware level. Instructions in assembly work on registers and memory addresses without enforcing a type system like those found in high-level languages (e.g., C, Java, or Haskell). There’s no built-in mechanism to restrict operations to certain “types” of data. | Interpretation of Data: In assembly, data is essentially just bits. How those bits are interpreted (as integers, floating-point numbers, characters, etc.) is determined by the instructions or by the programmer’s intent rather than by a type-checking system. | No Compile-Time Type Checking: Static typing in high-level languages means the compiler enforces type rules at compile time. Assembly language assemblers do not perform such type checking, so they do not enforce data types before the program runs. | Responsibility on the Programmer: Since assembly does not check types, it is up to the programmer to ensure that they are using data and instructions correctly. Misinterpreting data (for example, treating an address as data or vice versa) can lead to incorrect behavior, but the assembler won’t flag this as a type error. | . In summary, assembly language is not statically typed; it simply lacks a type system altogether, leaving all type management and interpretation up to the programmer. ",
    "url": "/2025-03-04-Assembly%20language.html#static-typing",
    
    "relUrl": "/2025-03-04-Assembly%20language.html#static-typing"
  },"73": {
    "doc": "Assembly language",
    "title": "Example code",
    "content": "Below is an example of an x86 Assembly algorithm written in NASM syntax that searches for a value in a binary search tree. In this example, each node of the tree is assumed to have the following structure (in C notation): .   struct Node {     int value; ; 4 bytes at offset 0     struct Node *left; ; 4 bytes at offset 4     struct Node *right; ; 4 bytes at offset 8   }; . The function bst_find takes two arguments:  • A pointer to the root node (first argument)  • The target value to be found (second argument) . It returns in EAX a pointer to the node that contains the specified value, or 0 if the value is not found. Below is the complete assembly code: . ;---------------------------------------------------------------------------- ; binary_search_tree.asm ;---------------------------------------------------------------------------- ; This routine implements a binary search in a binary search tree. ; Each node is assumed to have the following structure: ; ; struct Node { ; int value; ; offset 0 ; struct Node *left; ; offset 4 ; struct Node *right; ; offset 8 ; }; ; ; The function bst_find receives: ; - [ESP + 4] : Pointer to the root node ; - [ESP + 8] : Target value to search for ; ; It returns: ; - EAX : Pointer to the found node, or 0 if not found. ;---------------------------------------------------------------------------- SECTION .text global bst_find bst_find: push ebp mov ebp, esp ; Load arguments: ; First argument: pointer to root node mov esi, [ebp+8] ; Second argument: target value we are looking for mov ebx, [ebp+12] search_loop: ; If the current node pointer in ESI is NULL, value not found. cmp esi, 0 je not_found ; Load the current node's value (stored at offset 0) into EAX. mov eax, [esi] ; Compare the target value (in EBX) to the node's value. cmp ebx, eax je found ; The values are equal, node found. ; If target is less than current node's value, go to the left sub-tree. jl go_left ; Otherwise, go to the right sub-tree. mov esi, [esi+8] ; Pointer to right child (offset 8) jmp search_loop go_left: mov esi, [esi+4] ; Pointer to left child (offset 4) jmp search_loop found: ; Node found. Return pointer in EAX. mov eax, esi jmp finish not_found: ; Not found. Return 0. mov eax, 0 finish: mov esp, ebp pop ebp ret . Explanation . | Function Setup and Argument Retrieval: . | The function sets up the stack frame by pushing EBP and moving ESP into EBP. | It then loads the pointer to the root node into ESI and the target value into EBX. | . | Search Loop: . | The loop starts by checking if the current node pointer (ESI) is NULL. If it is, the search terminates because the value isn’t in the tree. | It retrieves the node’s value (from offset 0) and compares it with the target. | If the values are equal, it jumps to the found label. | If the target is less, the function moves to the left child (stored at offset 4). Otherwise, it moves to the right child (stored at offset 8). | . | Return: . | If the node is found, the pointer to that node is returned in EAX. | If not found, EAX is set to 0. | The function then restores the previous stack frame and returns. | . | . This example should be assembled with NASM and linked appropriately depending on your system and calling conventions. ",
    "url": "/2025-03-04-Assembly%20language.html#example-code",
    
    "relUrl": "/2025-03-04-Assembly%20language.html#example-code"
  },"74": {
    "doc": "Assembly language",
    "title": "Assembly language",
    "content": " ",
    "url": "/2025-03-04-Assembly%20language.html",
    
    "relUrl": "/2025-03-04-Assembly%20language.html"
  },"75": {
    "doc": "COBOL",
    "title": " COBOL",
    "content": " ",
    "url": "/2025-03-04-COBOL.html#-cobol",
    
    "relUrl": "/2025-03-04-COBOL.html#-cobol"
  },"76": {
    "doc": "COBOL",
    "title": "Official website",
    "content": "COBOL isn’t governed by a single organization that maintains an “official” website. Instead, it’s a standardized programming language with its specifications maintained by international standards organizations such as ISO (International Organization for Standardization) and IEC (International Electrotechnical Commission). For example, the most recent ISO/IEC standard for COBOL (ISO/IEC 1989) is what defines the language today. That said, there are several reputable resources and vendor sites related to COBOL: . • ISO/IEC 1989 Information: You can search for the ISO/IEC 1989:2014 standard through the ISO website or through national standards bodies—but note that obtaining the full standard document usually requires a purchase. • GNU COBOL: Formerly known as OpenCOBOL, GNU COBOL is a free COBOL compiler. Its project page can be found here:   https://www.gnu.org/software/gnucobol/ . • Vendor/Commercial Sites:   – Micro Focus provides COBOL tools and support, and you can explore their COBOL offerings at:    https://www.microfocus.com/en-us/products/cobol-general-purpose-platform/overview   – IBM offers COBOL compilers as part of its enterprise solutions, and more information is available on their website. In summary, if you’re looking for the “official” source of COBOL standards, your best bet is to refer to the ISO/IEC documentation. For practical implementations and community resources, the GNU COBOL website or vendor sites like those of Micro Focus and IBM are good references. ",
    "url": "/2025-03-04-COBOL.html#official-website",
    
    "relUrl": "/2025-03-04-COBOL.html#official-website"
  },"77": {
    "doc": "COBOL",
    "title": "Static typing",
    "content": "Yes, COBOL is considered a statically typed language. In COBOL, you declare all variables in the DATA DIVISION with specific types (such as numeric, alphanumeric, etc.) and sizes before they are used. This means that type checking occurs at compile time rather than at runtime. Some characteristics to note are: . | Variables and their data types must be defined upfront. | The compiler checks that operations involving these variables respect their declared types. | Although COBOL’s type system can be less strict compared to some modern languages, the types (e.g., numeric, alphanumeric) are still established statically. | . So while COBOL might be seen as having a simpler or more limited type system, it is indeed statically typed. ",
    "url": "/2025-03-04-COBOL.html#static-typing",
    
    "relUrl": "/2025-03-04-COBOL.html#static-typing"
  },"78": {
    "doc": "COBOL",
    "title": "Example code",
    "content": "Below is an example of a COBOL program that implements a binary search tree search algorithm. In COBOL you do not have built‐in pointer types as in other languages—but you can simulate dynamic data structures using the POINTER data type and by defining your own records. In this example, we define a record for a tree node that contains a numeric value and two pointer fields (for the left and right children). The binary search “find” routine starts at the root node and traverses left or right depending on whether the search key is less than or greater than the current node’s value. Note that this example assumes that the tree has been built already (perhaps by another part of your system) and that you have a pointer to the root node. The search algorithm uses the standard binary search tree lookup method. Below is the complete COBOL code: . IDENTIFICATION DIVISION. PROGRAM-ID. BST-SEARCH. ENVIRONMENT DIVISION. CONFIGURATION SECTION. DATA DIVISION. WORKING-STORAGE SECTION. * Define the search value we are looking for. 77 SEARCH-VALUE PIC S9(4) COMP VALUE 1234. * Flag to indicate whether the value was found. 77 VALUE-FOUND PIC X VALUE 'N'. * Pointer for traversing the tree. 77 CURRENT-NODE USAGE IS POINTER. * Declaration of a tree node record. * For this example the node contains: * - VALUE: the numeric value stored at the node. * - LEFT-CHILD and RIGHT-CHILD: pointers to other nodes. 01 TREE-NODE. 05 TN-VALUE PIC S9(4) COMP. 05 TN-LEFT USAGE IS POINTER. 05 TN-RIGHT USAGE IS POINTER. * For simulation, assume we have a static tree in memory. * In a real dynamic application, these nodes would be allocated dynamically. 01 ROOT-NODE USAGE IS POINTER. * We create some dummy nodes to simulate a pre-built tree. 01 NODE-A. 05 NODE-A-VALUE PIC S9(4) COMP VALUE 1000. 05 NODE-A-LEFT USAGE IS POINTER VALUE NULL. 05 NODE-A-RIGHT USAGE IS POINTER VALUE NULL. 01 NODE-B. 05 NODE-B-VALUE PIC S9(4) COMP VALUE 2000. 05 NODE-B-LEFT USAGE IS POINTER VALUE NULL. 05 NODE-B-RIGHT USAGE IS POINTER VALUE NULL. 01 NODE-ROOT. 05 NODE-ROOT-VALUE PIC S9(4) COMP VALUE 1500. 05 NODE-ROOT-LEFT USAGE IS POINTER. 05 NODE-ROOT-RIGHT USAGE IS POINTER. PROCEDURE DIVISION. MAIN-PROCEDURE. * Construct a simple binary search tree: * 1500 * / \\ * 1000 2000 * * Link the nodes together. MOVE ADDRESS OF NODE-A TO NODE-ROOT-LEFT. MOVE ADDRESS OF NODE-B TO NODE-ROOT-RIGHT. MOVE ADDRESS OF NODE-ROOT TO ROOT-NODE. * Start at the root node. MOVE ROOT-NODE TO CURRENT-NODE. PERFORM UNTIL CURRENT-NODE = NULL OR VALUE-FOUND = 'Y' * Dereference the CURRENT-NODE pointer into TREE-NODE structure. PERFORM GET-NODE-DATA IF TN-VALUE = SEARCH-VALUE MOVE 'Y' TO VALUE-FOUND ELSE IF SEARCH-VALUE &lt; TN-VALUE MOVE TN-LEFT TO CURRENT-NODE ELSE MOVE TN-RIGHT TO CURRENT-NODE END-IF END-IF END-PERFORM. IF VALUE-FOUND = 'Y' DISPLAY \"Value \" SEARCH-VALUE \" FOUND in the tree.\" ELSE DISPLAY \"Value \" SEARCH-VALUE \" NOT FOUND in the tree.\" END-IF. STOP RUN. * The GET-NODE-DATA routine moves the data from the node at CURRENT-NODE * into the working storage buffer TREE-NODE. In COBOL, pointer dereferencing is * achieved by a CALL to a routine that uses the ADDRESS OF clause. * However, for demonstration purposes, we simulate this by using a linkage mechanism. GET-NODE-DATA. PROCEDURE DIVISION USING CURRENT-NODE. EVALUATE TRUE WHEN CURRENT-NODE = ADDRESS OF NODE-ROOT MOVE NODE-ROOT-VALUE TO TN-VALUE MOVE NODE-ROOT-LEFT TO TN-LEFT MOVE NODE-ROOT-RIGHT TO TN-RIGHT WHEN CURRENT-NODE = ADDRESS OF NODE-A MOVE NODE-A-VALUE TO TN-VALUE MOVE NODE-A-LEFT TO TN-LEFT MOVE NODE-A-RIGHT TO TN-RIGHT WHEN CURRENT-NODE = ADDRESS OF NODE-B MOVE NODE-B-VALUE TO TN-VALUE MOVE NODE-B-LEFT TO TN-LEFT MOVE NODE-B-RIGHT TO TN-RIGHT WHEN OTHER DISPLAY \"Error: Unknown node address.\" MOVE NULL TO TN-VALUE MOVE NULL TO TN-LEFT MOVE NULL TO TN-RIGHT END-EVALUATE. EXIT. Explanation: . | The program defines a binary search tree with three nodes. The root has the value 1500 with left child 1000 and right child 2000. | The SEARCH-VALUE is defined as 1234. When you run the program, the search algorithm starts from the root and compares: . | Since 1234 is less than 1500, it moves to the left subtree. | At the left child, whose value is 1000, 1234 is greater than 1000 so it would move to the right. | Since NODE-A’s right pointer is NULL, the loop will end and indicate that the value was not found. | . | The GET-NODE-DATA routine simulates pointer dereferencing by comparing the CURRENT-NODE to known addresses (using ADDRESS OF the static nodes). In a full implementation where you dynamically allocate nodes, you would use system services or a runtime library to properly manage the memory and dereference pointers. | Finally, the program displays whether the searched value was found. | . This example should compile using a COBOL compiler. Adjust the pointer and memory management details according to your system’s COBOL implementation if dynamic memory allocation is available or needed. ",
    "url": "/2025-03-04-COBOL.html#example-code",
    
    "relUrl": "/2025-03-04-COBOL.html#example-code"
  },"79": {
    "doc": "COBOL",
    "title": "COBOL",
    "content": " ",
    "url": "/2025-03-04-COBOL.html",
    
    "relUrl": "/2025-03-04-COBOL.html"
  },"80": {
    "doc": "MATLAB",
    "title": " MATLAB",
    "content": " ",
    "url": "/2025-03-04-MATLAB.html#-matlab",
    
    "relUrl": "/2025-03-04-MATLAB.html#-matlab"
  },"81": {
    "doc": "MATLAB",
    "title": "Official website",
    "content": "The official MATLAB website can be found here: https://www.mathworks.com/products/matlab.html . This page is provided by MathWorks, the company that develops MATLAB. You can find more information about MATLAB, including documentation, licensing, and purchase details, on the site. ",
    "url": "/2025-03-04-MATLAB.html#official-website",
    
    "relUrl": "/2025-03-04-MATLAB.html#official-website"
  },"82": {
    "doc": "MATLAB",
    "title": "Static typing",
    "content": "MATLAB is a dynamically typed language. This means that: . | No Static Type Declaration: You don’t need to declare the data type of a variable before using it. You simply assign a value, and MATLAB determines the variable’s type at runtime. | Runtime Type Resolution: The type of a variable is determined as the program runs, and the type can even change if you later assign a value of a different type to the same variable. | Flexibility with Variables: This dynamic typing allows for greater flexibility in coding, but it also means that some type-related errors may only be caught during execution rather than at compile-time. | . In summary, MATLAB does not perform static type checking but relies on dynamic type determination during program execution. ",
    "url": "/2025-03-04-MATLAB.html#static-typing",
    
    "relUrl": "/2025-03-04-MATLAB.html#static-typing"
  },"83": {
    "doc": "MATLAB",
    "title": "Example code",
    "content": "Below is one way to implement a binary search tree (BST) lookup function in MATLAB. In this example: . • A BST node is represented as a structure with fields: . | value: The value stored in the node. | left: A pointer (structure) to the left child (or [] if none). | right: A pointer (structure) to the right child (or [] if none). | . • The function bst_find recursively traverses the BST looking for the given value. If the value is found, the function returns the node (i.e., the structure). If not found, it returns an empty array ([]). Below is the complete MATLAB code: . function node = bst_find(root, target) % bst_find searches for target value in a binary search tree. % % Parameters: % root - The root node of the BST (a structure with fields 'value', 'left', 'right'). % target - The value you want to search for. % % Returns: % node - The node containing the target value, or [] if not found. if isempty(root) % Base case: tree is empty – not found. node = []; return; end if target == root.value % Found the target value at the current node. node = root; return; elseif target &lt; root.value % If the target is less than the current node, % search in the left subtree. node = bst_find(root.left, target); else % Otherwise, search in the right subtree. node = bst_find(root.right, target); end end . Example Usage . Here’s how you might build a sample binary search tree and then search for a value using the above function. % Create nodes for the BST node7 = struct('value', 70, 'left', [], 'right', []); node6 = struct('value', 30, 'left', [], 'right', []); node5 = struct('value', 100, 'left', [], 'right', []); node4 = struct('value', 10, 'left', [], 'right', []); node3 = struct('value', 50, 'left', node6, 'right', node7); node2 = struct('value', 25, 'left', node4, 'right', node5); node1 = struct('value', 40, 'left', node2, 'right', node3); % node1 is the root of the BST. % Search for a value targetValue = 10; result = bst_find(node1, targetValue); if isempty(result) fprintf('Value %d not found in the BST.\\n', targetValue); else fprintf('Value %d found in the BST.\\n', result.value); end . How the Code Works . | The function bst_find is defined to search a BST recursively. | When the function is called: . | If the current node (root) is empty, it returns [] (indicating that the target is not found). | If the value in the current node matches the target, it returns the node. | Otherwise, it moves to the left subtree if the target is smaller than the current node’s value or to the right subtree if larger. | . | An example BST is created using MATLAB structures and then search is performed on it. | . This algorithm takes advantage of the BST property (left child &lt; parent &lt; right child) to efficiently search for a value. ",
    "url": "/2025-03-04-MATLAB.html#example-code",
    
    "relUrl": "/2025-03-04-MATLAB.html#example-code"
  },"84": {
    "doc": "MATLAB",
    "title": "MATLAB",
    "content": " ",
    "url": "/2025-03-04-MATLAB.html",
    
    "relUrl": "/2025-03-04-MATLAB.html"
  },"85": {
    "doc": "Prolog",
    "title": " Prolog",
    "content": " ",
    "url": "/2025-03-04-Prolog.html#-prolog",
    
    "relUrl": "/2025-03-04-Prolog.html#-prolog"
  },"86": {
    "doc": "Prolog",
    "title": "Official website",
    "content": "Prolog is not managed by a single organization, so there isn’t one “official” website for the language as a whole. Instead, there are several well‐established implementations and communities that support Prolog. Here are a few notable ones: . • SWI-Prolog: A widely used and actively developed implementation. Their official website is http://www.swi-prolog.org. • GNU Prolog: An open-source Prolog compiler with constraint solving over finite domains. More information can be found at https://www.gnu.org/software/prolog/. • SICStus Prolog: A high-performance commercial Prolog system used primarily in academia and industry. Details are available at https://sicstus.sics.se/. If you are looking for standards or historical context, you might also explore academic sites, but for practical usage, the above implementations are the go-to resources. ",
    "url": "/2025-03-04-Prolog.html#official-website",
    
    "relUrl": "/2025-03-04-Prolog.html#official-website"
  },"87": {
    "doc": "Prolog",
    "title": "Static typing",
    "content": "Prolog is generally considered an untyped or dynamically typed language. Here’s why: . | No explicit type declarations: In Prolog, you don’t declare variables or predicates with specific types as you might in statically typed languages. You simply work with terms such as atoms, numbers, lists, etc. | Terms with implicit “types”: While Prolog doesn’t enforce types at compile time, it does have different kinds of terms (e.g., atoms, numbers, variables, structures). The “type” of a term is determined at runtime through pattern matching and unification. | Unification: Prolog’s core mechanism is unification, which is performed at runtime and doesn’t require type declarations. This means that the language resolves the types (or, more precisely, the forms) of terms dynamically during execution. | Some implementations: Some modern Prolog implementations introduce features that allow for type-checking or type declarations as an extension or for debugging purposes. However, these features are not part of the standard language, which remains untyped or dynamically typed. | . In summary, Prolog does not have a static type system in the way that languages like Java or Haskell do, but it does have a notion of built-in term types that are managed dynamically at runtime. ",
    "url": "/2025-03-04-Prolog.html#static-typing",
    
    "relUrl": "/2025-03-04-Prolog.html#static-typing"
  },"88": {
    "doc": "Prolog",
    "title": "Example code",
    "content": "Below is an example of a Prolog algorithm that searches for a value in a binary search tree (BST). In this example, the BST is represented with the functor tree(Left, Root, Right) where an empty tree is represented by the atom nil. % search_bst(Tree, Value) % Succeeds if Value is found in the BST Tree. % Base case: an empty tree does not contain any value. search_bst(nil, _) :- fail. % When the Value is equal to the root's value, we've found it. search_bst(tree(_, Root, _), Value) :- Value =:= Root. % When the Value is less than the Root, search in the left subtree. search_bst(tree(Left, Root, _), Value) :- Value &lt; Root, search_bst(Left, Value). % When the Value is greater than the Root, search in the right subtree. search_bst(tree(_, Root, Right), Value) :- Value &gt; Root, search_bst(Right, Value). Explanation . | Representation of the BST: . | A non-empty node is represented as tree(Left, Root, Right). | An empty tree is represented as nil. | . | Predicate search_bst/2: . | The first clause handles an empty tree. If the tree is nil, the predicate fails (fail). | The second clause checks if the value at the current node (Root) is equal to Value using the arithmetic equality operator =:=. | The third clause checks whether the searched Value is less than Root. If so, it recursively searches the left subtree. | The fourth clause checks whether the searched Value is greater than Root. If so, it recursively searches the right subtree. | . | . Example Usage . Suppose we have the following BST: . 8 / \\ 3 10 / \\ \\ 1 6 14 / \\ / 4 7 13 . We can represent this tree in Prolog as: . Tree = tree( tree( tree(nil, 1, nil), 3, tree( tree(nil, 4, nil), 6, tree(nil, 7, nil) ) ), 8, tree( nil, 10, tree( tree(nil, 13, nil), 14, nil ) ) ). To search for the value 7 in this tree, you would run: . ?- Tree = tree(tree(tree(nil,1,nil),3,tree(tree(nil,4,nil),6,tree(nil,7,nil))),8,tree(nil,10,tree(tree(nil,13,nil),14,nil))), search_bst(Tree, 7). If the value 7 is found, the query succeeds; otherwise, it fails. ",
    "url": "/2025-03-04-Prolog.html#example-code",
    
    "relUrl": "/2025-03-04-Prolog.html#example-code"
  },"89": {
    "doc": "Prolog",
    "title": "Prolog",
    "content": " ",
    "url": "/2025-03-04-Prolog.html",
    
    "relUrl": "/2025-03-04-Prolog.html"
  },"90": {
    "doc": "R",
    "title": " R",
    "content": " ",
    "url": "/2025-03-04-R.html#-r",
    
    "relUrl": "/2025-03-04-R.html#-r"
  },"91": {
    "doc": "R",
    "title": "Official website",
    "content": "The official website for the R programming language is: . https://www.r-project.org/ . ",
    "url": "/2025-03-04-R.html#official-website",
    
    "relUrl": "/2025-03-04-R.html#official-website"
  },"92": {
    "doc": "R",
    "title": "Static typing",
    "content": "R is not statically typed; it is dynamically typed. In R, types are checked at runtime rather than during the compilation process. This means: . | You can assign any type of value to a variable without declaring its data type beforehand. | Type errors will be caught when the code is executed rather than before the code is run. | . For example, you can assign a numeric value to a variable one moment and then assign a character string to the same variable later without encountering a type declaration error. This flexibility is a characteristic of dynamically typed languages like R. ",
    "url": "/2025-03-04-R.html#static-typing",
    
    "relUrl": "/2025-03-04-R.html#static-typing"
  },"93": {
    "doc": "R",
    "title": "Example code",
    "content": "Below is an example of how you can implement a binary search tree (BST) search in R. In this example, we first define a simple BST structure using lists (each node is a list with a value, a left child, and a right child). Then we create a recursive function, findInBST, which searches for a given target value within the tree. # Define a function to create a new BST node newNode &lt;- function(value, left = NULL, right = NULL) { list(value = value, left = left, right = right) } # Recursive function to search for a value in the BST. # Returns the node if found, or NULL if not found. findInBST &lt;- function(root, target) { # if the tree is empty, return NULL if (is.null(root)) { return(NULL) } # if the current node's value matches the target, return the node if (root$value == target) { return(root) } # if target is smaller than node's value, search the left subtree if (target &lt; root$value) { return(findInBST(root$left, target)) } else { # if target is larger than node's value, search the right subtree return(findInBST(root$right, target)) } } # Example usage: # Manually constructing a binary search tree: # 8 # / \\ # 3 10 # / \\ \\ # 1 6 14 # / \\ # 4 7 node1 &lt;- newNode(1) node4 &lt;- newNode(4) node7 &lt;- newNode(7) node6 &lt;- newNode(6, left = node4, right = node7) node3 &lt;- newNode(3, left = node1, right = node6) node14 &lt;- newNode(14) node10 &lt;- newNode(10, right = node14) root &lt;- newNode(8, left = node3, right = node10) # Searching for a value targetValue &lt;- 7 result &lt;- findInBST(root, targetValue) if (!is.null(result)) { cat(\"Found:\", result$value, \"\\n\") } else { cat(\"Value\", targetValue, \"not found in the BST.\\n\") } . Explanation . | Node Structure: We create a node as a list that holds the current value and pointers (left and right) to its children. The helper function newNode makes node creation concise. | Search Function (findInBST): . | It first checks if the current node (root) is NULL. If yes, it returns NULL meaning the target is not found. | If the node’s value equals the target, it returns the current node. | If the target is less than the node’s value, the function recursively searches the left subtree. | Otherwise, it recursively searches the right subtree. | . | Example Tree and Usage: We create a simple BST manually and demonstrate how to search for a value, printing the result. | . This code can be run directly in an R environment, and you can modify it further if needed. ",
    "url": "/2025-03-04-R.html#example-code",
    
    "relUrl": "/2025-03-04-R.html#example-code"
  },"94": {
    "doc": "R",
    "title": "R",
    "content": " ",
    "url": "/2025-03-04-R.html",
    
    "relUrl": "/2025-03-04-R.html"
  },"95": {
    "doc": "Ruby",
    "title": " Ruby",
    "content": " ",
    "url": "/2025-03-04-Ruby.html#-ruby",
    
    "relUrl": "/2025-03-04-Ruby.html#-ruby"
  },"96": {
    "doc": "Ruby",
    "title": "Official website",
    "content": "The official website for the Ruby programming language is: https://www.ruby-lang.org/ . ",
    "url": "/2025-03-04-Ruby.html#official-website",
    
    "relUrl": "/2025-03-04-Ruby.html#official-website"
  },"97": {
    "doc": "Ruby",
    "title": "Static typing",
    "content": "No, Ruby is not statically typed; it is a dynamically typed language. In Ruby, type checking happens at runtime, meaning that variables can reference objects of any type without explicit type declarations, and type errors are typically detected only when the problematic code is executed. ",
    "url": "/2025-03-04-Ruby.html#static-typing",
    
    "relUrl": "/2025-03-04-Ruby.html#static-typing"
  },"98": {
    "doc": "Ruby",
    "title": "Example code",
    "content": "Below is a complete Ruby implementation of a binary search tree (BST) along with a method to find (search for) a value in the tree. The algorithm uses recursion to traverse the tree according to the BST property. You can run this code directly in a Ruby environment. # Define a Node class for the binary search tree. class Node attr_accessor :value, :left, :right def initialize(value) @value = value @left = nil @right = nil end end # Define a BST class that holds the root node. class BinarySearchTree attr_accessor :root def initialize @root = nil end # Insert a new value into the BST. def insert(value) @root = insert_recursively(@root, value) end # Recursive method to insert a new node. def insert_recursively(current_node, value) if current_node.nil? return Node.new(value) end if value &lt; current_node.value current_node.left = insert_recursively(current_node.left, value) elsif value &gt; current_node.value current_node.right = insert_recursively(current_node.right, value) else # Duplicate value, no insertion is done. puts \"Value #{value} already exists in the tree.\" end current_node end # Find a value in the BST. Returns the node if found, otherwise returns nil. def find(value) find_recursively(@root, value) end # Recursive search method. def find_recursively(current_node, value) return nil if current_node.nil? if value == current_node.value return current_node elsif value &lt; current_node.value return find_recursively(current_node.left, value) else return find_recursively(current_node.right, value) end end end # Example Usage: # Create a new binary search tree. bst = BinarySearchTree.new # Insert some values. [15, 10, 20, 8, 12, 17, 25].each { |value| bst.insert(value) } # Search for a value in the BST. search_value = 17 found_node = bst.find(search_value) if found_node puts \"Found value #{found_node.value} in the binary search tree.\" else puts \"Value #{search_value} not found in the binary search tree.\" end . Explanation . | Node Class: . | Each node stores a value and has pointers to its left and right child nodes. | . | Binary Search Tree Class: . | The BST holds a reference to the root node. | The insert method inserts values maintaining BST properties, using a helper recursive method. | The find method searches for a given value by recursively comparing the target value with the current node’s value. It follows the left subtree if the value is less and the right subtree if it’s greater. | . | Execution: . | The code block creates a BST, inserts several values, and then searches for a specific value, reporting whether it was found. | . | . This implementation is complete, runnable, and demonstrates the essential operations of a binary search tree in Ruby. ",
    "url": "/2025-03-04-Ruby.html#example-code",
    
    "relUrl": "/2025-03-04-Ruby.html#example-code"
  },"99": {
    "doc": "Ruby",
    "title": "Ruby",
    "content": " ",
    "url": "/2025-03-04-Ruby.html",
    
    "relUrl": "/2025-03-04-Ruby.html"
  }
}
